{% extends 'chat/home.html' %}
{% block subcontent %}
    <h1>{{ other_user }}</h1>

    <div id="chat-error"></div>
    <div id="friendship-status">
        {% if not are_friends %}
            {% include 'chat/snippets/not_friends_text.html' %}
        {% endif %}
    </div>

    <!-- BUG: load ws message is sent twice, added 1ms delay as a workaround -->
    <div ws-send hx-trigger="load delay:1ms" hx-vals='{"type":"chat_load", "other_user":"{{ other_user }}"}'></div>
    <div ws-send hx-trigger="beforeunload from:window" hx-vals='{"type":"chat_unload"}'></div>

    <form id="form" ws-send hx-vals='{"type":"chat_send"}'>
        <input id="chat-input" name="content">
    </form>

    <div id="messages">
        {% for group in grouped_messages %}
            <p>{{ group.date|date:'Y-m-d' }}</p>
            {% for message in group.messages %}
                {% include 'chat/snippets/message.html' %}
            {% endfor %}
        {% endfor %}
    </div>

    <script>




        // UPDATE READ STATUS OF THE MESSAGE IN THE RECENT CHATS PART TO TRUE WHEN READ - ONLY SHOW READ STATUS IF YOU ARE THE ONE WHO SENT IT
        // CLEAR NEW PART IN MESSAGES WHEN THE USER SENDS OR RECEIVES SOMETHING?




        let areFriends = '{{ are_friends }}' === 'True'; // Convert string to boolean

        document.body.addEventListener('htmx:wsConfigSend', (event) => {
            const content = event.detail.parameters.content;
            if (content === undefined) {
                // The event was triggered by either chat load or unload 
                return;
            }
            // Cancel event and don't send message if the users don't have a mutual friendship, or if the message is blank
            if (!areFriends || !content.trim()) {
                event.preventDefault();
            }
        });

        document.body.addEventListener('htmx:wsAfterSend', (event) => {
            const chatInputELement = document.getElementById('chat-input');
            chatInputELement.value = '';
        });

        function setAllMessagesRead(reader) {
            const messageElements = document.querySelectorAll(`.message[data-sender="{{ user.username }}"][data-read="False"]`);
            messageElements.forEach(updateMessageReadStatus);
        }

        function setMessageRead(messageId) {
            const messageElement = document.getElementById(`message-${messageId}`);
            if (messageElement && messageElement.dataset.read === 'False') {
                updateMessageReadStatus(messageElement);
            }
        }

        function updateMessageReadStatus(messageElement) {
            messageElement.dataset.read = 'True';
            const readStatusElement = messageElement.querySelector('.read-status');
            readStatusElement.textContent = 'Read: True';
        }

        function displayChatErrorMessage() {
            const chatErrorElement = document.getElementById('chat-error');
            chatErrorElement.innerHTML = '{% include "chat/snippets/error_text.html" %}';
        }

        function handleFriendshipCreated() {
            areFriends = true;
            const friendshipStatusElement = document.getElementById('friendship-status');
            friendshipStatusElement.textContent = '';
        }

        function handleFriendshipRemoved() {
            areFriends = false;
            const friendshipStatusElement = document.getElementById('friendship-status');
            friendshipStatusElement.innerHTML = '{% include "chat/snippets/not_friends_text.html" %}';
        }
    </script>
{% endblock subcontent %}